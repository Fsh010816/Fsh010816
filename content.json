{"meta":{"title":"Fsh","subtitle":"Fsh","description":"","author":"fsh","url":"http://Fsh010816.github.io","root":"/"},"pages":[{"title":"404","date":"2020-12-19T07:26:40.000Z","updated":"2020-12-19T07:27:00.079Z","comments":true,"path":"404/index.html","permalink":"http://fsh010816.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2020-12-19T07:18:58.000Z","updated":"2020-12-19T07:19:41.315Z","comments":true,"path":"about/index.html","permalink":"http://fsh010816.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-12-19T07:23:23.000Z","updated":"2020-12-19T07:23:41.727Z","comments":true,"path":"friends/index.html","permalink":"http://fsh010816.github.io/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-12-19T07:15:58.000Z","updated":"2020-12-19T07:20:10.752Z","comments":true,"path":"categories/index.html","permalink":"http://fsh010816.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-12-19T07:20:51.000Z","updated":"2020-12-19T07:21:08.106Z","comments":true,"path":"contact/index.html","permalink":"http://fsh010816.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-19T07:18:26.000Z","updated":"2020-12-19T07:20:23.582Z","comments":true,"path":"tags/index.html","permalink":"http://fsh010816.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"5-面向对象(中)","slug":"5-面向对象-中","date":"2021-01-19T12:34:49.000Z","updated":"2021-01-21T08:06:44.824Z","comments":true,"path":"2021/01/19/5-mian-xiang-dui-xiang-zhong/","link":"","permalink":"http://fsh010816.github.io/2021/01/19/5-mian-xiang-dui-xiang-zhong/","excerpt":"","text":"# 面向对象 (中) # 继承性 # 好处 1. 继承的出现减少了代码冗余，提高了代码的复用性。 2. 继承的出现，更有利于功能的扩展。 3. 继承的出现让类与类之间产生了关系，提供了多态的前提。 # 格式 class A extends B{} 2.1 体现：一旦子类 A 继承父类 B 以后，子类 A 中就获取了父类 B 中声明的所有的属性和方法。特别的，父类中声明为 private 的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。只有因为封装性的影响，使得子类不能直接调用父类的结构而已。 2.2 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。子类和父类的关系，不同于子集和集合的关系。extends：延展、扩展 三、Java 中关于继承性的规定： 1. 一个类可以被多个子类继承。 2.Java 中类的单继承性：一个类只能有一个父类 3. 子父类是相对的概念。 4. 子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类 5. 子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法 四、 1. 如果我们没有显式的声明一个类的父类的话，则此类继承于 java.lang.Object 类 2. 所有的 java 类（除 java.lang.Object 类之外）都直接或间接的继承于 java.lang.Object 类 3. 意味着，所有的 java 类具有 java.lang.Object 类声明的功能。 # 重写 # 定义 在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。 # 规定 方法的声明： 权限修饰符 返回值类型 方法名 (形参列表) throws 异常的类型 { //方法体 ​ } 约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法 ① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同 ② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符 特殊情况：子类不能重写父类中声明为private权限的方法 ③ 返回值类型： 父类被重写的方法的返回值类型是 void，则子类重写的方法的返回值类型只能是 void 父类被重写的方法的返回值类型是 A 类型，则子类重写的方法的返回值类型可以是 A 类或 A 类的子类 父类被重写的方法的返回值类型是基本数据类型 (比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型 (必须也是 double) ④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型 子类和父类中的同名同参数的方法要么都声明为非 static 的（考虑重写），要么都声明为 static 的（不是重写）。 # super super 关键字的使用 1.super 理解为：父类的 2.super 可以用来调用：属性、方法、构造器 3.super 的使用：调用属性和方法 3.1 我们可以在子类的方法或构造器中。通过使用 \"super. 属性\" 或 \"super. 方法\" 的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略 \"super.\" 3.2 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的 使用 \"super. 属性\" 的方式，表明调用的是父类中声明的属性。 3.3 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用 \"super. 方法\" 的方式，表明调用的是父类中被重写的方法。 4.super 调用构造器 4.1 我们可以在子类的构造器中显式的使用 \"super (形参列表)\" 的方式，调用父类中声明的指定的构造器 4.2 \"super (形参列表)\" 的使用，必须声明在子类构造器的首行！ 4.3 我们在类的构造器中，针对于 \"this (形参列表)\" 或 \"super (形参列表)\" 只能二选一，不能同时出现 4.4 在构造器的首行，没有显式的声明 \"this (形参列表)“或\"super (形参列表)”，则默认调用的是父类中空参的构造器：super () 4.5 在类的多个构造器中，至少有一个类的构造器中使用了 \"super (形参列表)\"，调用父类中的构造器 # 子类对象实例化的全过程 1. 从结果上来看：（继承性） 子类继承父类以后，就获取了父类中声明的属性或方法。 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。 2. 从过程上来看： 当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，… 直到调用了 java.lang.Object 类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。 明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为 new 的子类对象。 # 多态性 1. 何为多态性： 对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用） 2. 多态的使用：虚拟方法调用 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。 子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。 总结：编译，看左边；运行，看右边。 3. 多态性的使用前提： ① 类的继承关系 ② 方法的重写 4. 对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边） 5.Java 引用变量有两个类型： 编译时类型和 运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简称：编译时，看左边；运行时，看右边。 多态是运行时行为 6. 一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就 不能 再访问子类中添加的属性和方法 7. 若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中：编译看左边，运行看右边 对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量：编译运行都看左边 # 方法的重载与重写 二者的定义细节：略 从编译和运行的角度看： 重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java 的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。 所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为 “早绑定” 或 “静态绑定”；而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为 “晚绑定” 或 “动态绑定”。 # == ==：对于引用数据类型来讲，比较的是两个引用数据类型变量的地址值是否相同 # instanceof a instanceof A: 判断对象 a 是否是类 A 的实例。如果是，返回 true；如果不是，返回 false。 使用情境：为了避免在向下转型时出现 ClassCastException 的异常，我们在向下转型之前，先进行 instanceof 的判断，一旦返回 true，就进行向下转型。如果返回 false，不进行向下转型。 # java.lang.Object 类 1.Object 类是所有 Java 类的根父类 2. 如果在类的声明中未使用 extends 关键字指明其父类，则默认父类为 java.lang.Object 类 3.Object 类中的功能 (属性、方法) 就具有通用性。 属性：无 方法：equals () /toString () /getClass () /hashCode () /clone () /finalize ()、wait () 、 notify ()、notifyAll () 4.Object 类只声明了一个空参的构造器 # == equals() # == == ：运算符 1. 可以使用在基本数据类型变量和引用数据类型变量中 2. 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同） 如果比较的是引用数据类型变量：比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体 补充： == 符号使用时，必须保证符号左右两边的变量类型一致。 # equals () 方法的使用 1. 是一个方法，而非运算符 2. 只能适用于引用数据类型 3.Object 类中 equals () 的定义： public boolean equals(Object obj) { return (this == obj); } 说明：Object 类中定义的 equals () 和 == 的作用是相同的：比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体 4. 像 String、Date、File、包装类等都重写了 Object 类中的 equals () 方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的 \"实体内容\" 是否相同。 5. 通常情况下，我们自定义的类如果使用 equals () 的话，也通常是比较两个对象的 \"实体内容\" 是否相同。那么，我们就需要对 Object 类中的 equals () 进行重写. 重写的原则：比较两个对象的实体内容是否相同. # toString() 1. 当我们输出一个对象的引用时，实际上就是调用当前对象的 toString () 2.Object 类中 toString () 的定义： public String toString() { return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); } 3. 像 String、Date、File、包装类等都重写了 Object 类中的 toString () 方法。使得在调用对象的 toString () 时，返回 \"实体内容\" 信息 4. 自定义类也可以重写 toString () 方法，当调用此方法时，返回对象的 \"实体内容\" toString () 方法在 Object 类中定义 ，其返回值是 String 类型 ， 返回类名和它的引用地址 。 在进行 String 与其它类型数据的连接操作时 ，调用了自动调用 toString () 方法 基本类型数据转换为 String 类型时 ，调用了对应包装类的 toString () 方法 # 包装类 java 提供了 8 种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征 String 类型 —&gt; 基本数据类型、包装类：调用包装类的 parseXxx (String s) String str1 = \"123\"; int num2 = Integer.parseInt(str1); 基本数据类型、包装类 —&gt;String 类型：调用 String 重载的 valueOf (Xxx xxx) int num1 = 10; //方式1：连接运算 String str1 = num1 + \"\"; //方式2：调用String的valueOf(Xxx xxx) float f1 = 12.3f; String str2 = String.valueOf(f1);//\"12.3\" 基本数据类型 —&gt; 包装类：调用包装类的构造器 int num1 = 10; Integer in1 = new Integer(num1); System.out.println(in1.toString()); Integer in2 = new Integer(\"123\"); //通过字符串参数构造包装类对象 System.out.println(in2.toString()); Boolean b3 = new Boolean(\"true123\"); System.out.println(b3);//false 自动装箱：基本数据类型 —&gt; 包装类 int num2 = 10; Integer in1 = num2;//自动装箱 int num3 = in1;//自动拆箱 包装类 —&gt; 基本数据类型：调用包装类 Xxx 的 xxxValue () Integer in1 = new Integer(12); int i1 = in1.intValue(); 自动拆箱：包装类 —&gt; 基本数据类型 面试题 //Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[], //保存了从-128~127范围的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在 //-128~127范围内时，可以直接使用数组中的元素，不用再去new了。目的：提高效率 Integer m = 1; Integer n = 1; System.out.println(m == n);//true Integer x = 128;//相当于new了一个Integer对象 Integer y = 128;//相当于new了一个Integer对象 System.out.println(x == y);//false","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"4-面向对象(上)","slug":"4-面向对象-上","date":"2021-01-18T07:02:37.000Z","updated":"2021-01-20T03:50:47.355Z","comments":true,"path":"2021/01/18/4-mian-xiang-dui-xiang-shang/","link":"","permalink":"http://fsh010816.github.io/2021/01/18/4-mian-xiang-dui-xiang-shang/","excerpt":"","text":"# 面向对象 (上) # 类 (Class) 和对象 (Object) 类是对一类事物的描述，是抽象的、概念上的定义 对象是实际存在的该类事物的每个个体，因而也称为实例 (instance)。 # 类的成员 1 &gt; 属 性：对应类中的成员变量 2 &gt; 行 为：对应类中的成员方法 Field = 属性 = 成员变量 = 域、字段，Method = (成员) 方法 = 函数 创建类的对象 = 类的实例化 = 实例化类 # 类和对象的使用 1. 创建类，设计类的成员 2. 创建类的对象 类名 对象名 = new 类名(); 3. 通过 “对象。属性” 或 “对象。方法” 调用对象的结构 # 类 修饰符 class 类名 { 属性声明; 方法声明; } 类的正文要用 { } 括起来 # 内存解析 编译完程序以后，生成一个或多个字节码文件， 我们使用 JVM 中的类的加载器和解释器对生成的字节码文件进行解释运行，意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析。 堆： 存放对象实例 对象的属性（非 static）new 出来的结构 对象（非 static 成员变量）数组 栈： 存储局部变量 方法区（Method Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 常量池 静态域 # 对象的内存解析 # 匿名对象 我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。 如：new Person ().shout (); 使用情况 1. 如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。 2. 我们经常将匿名对象作为实参传递给一个方法调用。 # 属性 (成员变量) 局部变量 # 相同点 1. 定义变量的格式：数据类型 变量名 = 变量值 2. 先声明，后使用 3. 变量都有其对应的作用域 # 不同点 1. 在类中声明的位置不同 成员变量：在方法体外，类体内声明的变量 局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量 2. 关于权限修饰符的不同 属性：可以在声明属性时，指明其权限，使用权限修饰符 ​ private、public、缺省、protected 局部变量：不可使用权限修饰符 3. 默认初始化值 属性：根据其类型，都有默认初始化值 局部变量：没有默认初始化值 ​ 调用局部变量前，必须显示赋值 ​ 特别地，形参在调用时，赋值即可 4. 在内存中加载的位置 属性：堆（非 static） 局部变量：栈 # 方法 Java 里的方法不能独立存在，所有的方法必须定义在类里。 # 声明 权限修饰符 返回值类型 方法名 （参数类型 形参1,参数类型 形参2, …）｛ 方法体程序代码 return 返回值; ｝ 返回值类型： ​ 没有返回值：void。 如果使用 return, 只能 \"return;\"，表示结束此方法的意思 ​ 有返回值，声明出返回值的类型。 # tips 方法的使用中，可以调用当前类的属性或方法 ​ （例外：static 方法访问非 static，编译不通过 。） 方法中，不可以定义方法 # 重载 概念：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。 # 可变个数的形参 JavaSE 5.0 中提供了 Varargs (variable number of arguments) 机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。 声明格式：方法名 (参数的类型名 … 参数名) 此参数名也有 length 属性 可变参数：方法参数部分指定类型的参数个数是可变多个：0 个，1 个或多个 可变参数方法的使用与方法参数部分使用数组是一致的 # 方法参数的值传递机制 Java 里方法的参数传递方式只有一种：值传递。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。 形参是基本数据类型：将实参基本数据类型变量的 “数据值” 传递给形参 形参是引用数据类型：将实参引用数据类型变量的 “地址值” 传递给形参 # 封装和隐藏 信息的封装和隐藏 Java 中通过将数据声明为私有的 (private)，再提供公共的（public）方法:getXxx () 和 setXxx () 实现对该属性的操作，以实现下述目的： 隐藏一个类中不需要对外提供的实现细节； 使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作； 便于修改，增强代码的可维护性 # 体现 1. 将类的属性私有化，同时，提供公共的方法来获取 (get) 和设置 (set) 此属性的值 2. 不对外暴露的私有的方法 3. 单例模式 (将构造器私有化) 4. 如果不希望类在包外被调用，可以将类设置为私有的 # 权限修饰符 4 种权限修饰符都可以修饰类的内部结构：属性、方法、构造器、内部类 修饰类，只能用：缺省和 public # 构造器 # 构造器的特征 它具有与类相同的名称 它不声明返回值类型。（与声明为 void 不同） 不能被 static、final、synchronized、abstract、native 修饰，不能有 return 语句返回值 # 构造器的作用 创建对象；给对象进行初始化 如：Order o = new Order (); Person p = new Person (“Peter”,15); # 语法格式 ： 修饰符名 类名 ( 参数列表) { 初始化语句； } 根据参数不同，构造器可以分为如下两类：  隐式无参构造器（系统默认提供）  显式定义一个或多个（无参、有参） # 注意： Java 语言中，每个类都至少有一个 构造器  默认构造器的修饰符与所属类的修饰符一致  一旦 显式定义了 构造器， 则系统 不再 提供默认 构造 器  一个类可以创建多个 重载 的构造器  父类的构造器不可被子类继承 # 属性赋值过程 赋值的位置： ① 默认初始化 ② 显式初始化 ③ 构造器中初始化 ④ 通过 “对象。属性 “或 “对象。方法” 的方式赋值 赋值的先后顺序：① - ② - ③ - ④ # JavaBean JavaBean 是一种 Java 语言写成的可重用组件。 所谓 javaBean，是指符合如下标准的 Java 类： 类是公共的 有一个无参的公共的构造器 有属性，且有对应的 get、set 方法 # this this 关键字的使用： 1.this 可以用来修饰、调用：属性、方法、构造器 2.this 修饰属性和方法： this 理解为：当前对象 或 当前正在创建的对象 2.1 在类的方法中，我们可以使用 \"this. 属性\" 或 \"this. 方法\" 的方式，调用当前对象属性或方法。但是，通常情况下，我们都选择省略 \"this.\"。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用 \"this. 变量\" 的方式，表明此变量是属性，而非形参。 2.2 在类的构造器中，我们可以使用 \"this. 属性\" 或 \"this. 方法\" 的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都选择省略 \"this.\"。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用 \"this. 变量\" 的方式，表明此变量是属性，而非形参。 2.3 使用 this 访问属性和方法时，如果在本类中未找到，会从父类中查找 this 调用构造器 ① 我们在类的构造器中，可以显式的使用 \"this (形参列表)\" 方式，调用本类中指定的其他构造器 ② 构造器中不能通过 \"this (形参列表)\" 方式调用自己 ③ 如果一个类中有 n 个构造器，则最多有 n - 1 构造器中使用了 \"this (形参列表)\" ④ 规定：\"this (形参列表)\" 必须声明在当前构造器的首行 ⑤ 构造器内部，最多只能声明一个 \"this (形参列表)\"，用来调用其他的构造器 # import 在源文件中使用 import 显式的导入指定包下的类或接口 如果已经导入 java.a 包下的类。那么如果需要使用 a 包的子包下的类的话，仍然需要导入。使用 \"xxx.*\" 方式表明可以调用 xxx 包下的所有结构。但是如果使用的是 xxx 子包下的结构，则仍需要显式导入 import static 组合的使用：调用指定类或接口下的静态的属性或方法 import static java.lang.System.*; out.println(\"hello\");","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"3-数组","slug":"3-数组","date":"2021-01-13T13:47:11.000Z","updated":"2021-01-18T06:50:37.675Z","comments":true,"path":"2021/01/13/3-shu-zu/","link":"","permalink":"http://fsh010816.github.io/2021/01/13/3-shu-zu/","excerpt":"","text":"# 数组 # 数组的概述 1 &gt; 数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型。 2 &gt; 创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址。 3 &gt; 数组的长度一旦确定，就不能修改。 # 一维数组 # 声明 type var[] 或 type[] var; Java 语言中声明数组时不能指定其长度 (数组中元素的数) # 初始化 # 静态初始化 静态初始化 ：在定义数组的同时就为数组元素分配空间并赋值。 int arr[] = new int[]{ 3, 9, 8}; 或 int[] arr = {3,9,8}; # 动态初始化 动态初始化 ：数组声明且为数组元素分配空间与赋值的操作分开进行 int[] arr = new int[3]; arr[0] = 3; arr[1] = 9; arr[2] = 8; # 数组元素的引用 数组元素下标可以是整型常量或整型表达式 数组元素下标从 0 开始 # 数组元素的默认初始化值 数组是引用类型，它的元素相当于类的成员变量，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化 # 内存解析 # 多维数组 # 二维数组的声明和初始化 静态初始化 int[][] arr = new int[][]{{3,8,2},{2,7},{9,0,1,6}}; System.out.println(arr.length); //3 System.out.println(arr[1].length); //2 int[][] arr = {{3,8,2},{2,7},{9,0,1,6}};//类型推断，只能一行时使用 注意特殊写法情况：int [] x,y []; x 是一维数组，y 是二维数组。 动态初始化 1 int[][] arr = new int[3][2]; System.out.println(arr[0]); //一维数组地址 System.out.println(arr[0][0]); //0 动态初始化 2 int[][] arr = new int[3][]; System.out.println(arr[0]); //null int[][] arr = new int[][3];//非法 # 二分法查找 前提：所要查找的数组有序 int arr1[] = new int[]{-98,-77,-55,-22,0,1,23,34,54,66,77,88,99}; int dest = 2; int head = 0; //初始的索引 int end = arr1.length - 1; //初始的末索引 boolean isFlag = true; while(head &lt;= end){ int middle = (head+end)/2; if(dest == arr1[middle]){ System.out.println(\"找到了，位置:\"+middle); isFlag = false; break; }else if(arr1[middle] &gt; dest){ end = middle - 1; }else{ head = middle + 1; } } if(isFlag){ System.out.println(\"没找到\"); } # 排序算法 # 衡量排序算法的优劣 1. 时间复杂度 2. 空间复杂度 3. 稳定性：若两个记录 A 和 B 的关键字值相等，但排序后 A、B 的先后次序保持不变，则称这种排序算法是稳定的。 # 分类 排序算法分类： 内部排序 和 外部排序 。 内部排序：整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。 外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。 # 冒泡排序 排序思想： 比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。 int arr[] = new int[]{22,33,11,-99,0,62,21}; //冒泡排序 for(int i = 0;i &lt; arr.length-1;i++){ for(int j = 0;j&lt;arr.length-1-i;j++){ if(arr[j]&gt;arr[j+1]){ int temp = arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } for(int i = 0;i&lt;arr.length;i++){ System.out.print(arr[i]+\" \"); } # 快速排序 # Arrays 工具类的使用 java.util.Arrays 1 boolean equals (int [] a,int [] b) 判断两个数组是否相等。 2 String toString (int [] a) 输出数组信息。 3 void fill (int [] a,int val) 将指定值填充到数组之中。 4 void sort (int [] a) 对数组进行排序。 5 int binarySearch (int [] a,int key) 对排序后的数组进行二分法检索指定的值。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"Eclipse","slug":"Eclipse","date":"2021-01-12T14:04:56.000Z","updated":"2021-01-21T04:42:48.494Z","comments":true,"path":"2021/01/12/eclipse/","link":"","permalink":"http://fsh010816.github.io/2021/01/12/eclipse/","excerpt":"","text":"# Eclipse # 结构 左侧： 结构 1： Package Explorer ​ 结构 2 ：Navigator ​ 结构 3：Outline 下面：结构 :4: Console # 配置 # 字符 # 字体 # 修改 new 菜单 # helloworld 先 new Java Project 在 src 下 new package 在包下 new class # 导入工程 # 提示功能 windows preferences . 改成 a-z. # 快捷键设置 windows preferences 搜索 keys # 快捷键 /* * Eclipse中的快捷键： * 1.补全代码的声明：alt + / * 2.快速修复: ctrl + 1 * 3.批量导包：ctrl + shift + o * 4.使用单行注释：ctrl + / * 5.使用多行注释： ctrl + shift + / * 6.取消多行注释：ctrl + shift + \\ * 7.复制指定行的代码：ctrl + alt + down 或 ctrl + alt + up * 8.删除指定行的代码：ctrl + d * 9.上下移动代码：alt + up 或 alt + down * 10.切换到下一行代码空位：shift + enter * 11.切换到上一行代码空位：ctrl + shift + enter * 12.如何查看源码：ctrl + 选中指定的结构 或 ctrl + shift + t * 13.退回到前一个编辑的页面：alt + left * 14.进入到下一个编辑的页面(针对于上面那条来说的)：alt + right * 15.光标选中指定的类，查看继承树结构：ctrl + t * 16.复制代码： ctrl + c * 17.撤销： ctrl + z * 18.反撤销： ctrl + y * 19.剪切：ctrl + x * 20.粘贴：ctrl + v * 21.保存： ctrl + s * 22.全选：ctrl + a * 23.格式化代码： ctrl + shift + f * 24.选中数行，整体往后移动：tab * 25.选中数行，整体往前移动：shift + tab * 26.在当前类中，显示类结构，并支持搜索指定的方法、属性等：ctrl + o * 27.批量修改指定的变量名、方法名、类名等：alt + shift + r * 28.选中的结构的大小写的切换：变成大写： ctrl + shift + x * 29.选中的结构的大小写的切换：变成小写：ctrl + shift + y * 30.调出生成getter/setter/构造器等结构： alt + shift + s * 31.显示当前选择资源(工程 or 文件)的属性：alt + enter * 32.快速查找：参照选中的Word快速定位到下一个 ：ctrl + k * * 33.关闭当前窗口：ctrl + w * 34.关闭所有的窗口：ctrl + shift + w * 35.查看指定的结构使用过的地方：ctrl + alt + g * 36.查找与替换：ctrl + f * 37.最大化当前的View：ctrl + m * 38.直接定位到当前行的首位：home * 39.直接定位到当前行的末位：end */ # Java 中的 JUnit 单元测试 步骤： 1. 选中当前工程 - 右键选择：build path - add libraries - JUnit 4 - 下一步 2. 创建 Java 类，进行单元测试。 此时的 Java 类要求：① 此类是 public 的 ②此类提供公共的无参的构造器 3. 此类中声明单元测试方法。 此时的单元测试方法：方法的权限是 public, 没有返回值，没有形参 4. 此单元测试方法上需要声明注解：@Test, 并在单元测试类中导入：import org.junit.Test; 5. 声明好单元测试方法以后，就可以在方法体内测试相关的代码。 6. 写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test 说明： 1. 如果执行结果没有任何异常：绿条 2. 如果执行结果出现异常：红条","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"2_Java基本语法","slug":"2-Java基本语法","date":"2021-01-09T02:11:52.000Z","updated":"2021-01-12T13:59:26.998Z","comments":true,"path":"2021/01/09/2-java-ji-ben-yu-fa/","link":"","permalink":"http://fsh010816.github.io/2021/01/09/2-java-ji-ben-yu-fa/","excerpt":"","text":"# Java 基本语法 # 关键字与保留字 # 关键字 定义：被 被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词） 特点： 关键字中所有字母都为小写 # 保留字 Java 保留字：现有 Java 版本尚未使用，但以后版本可能会作为关键字使 用。自己命名标识符时要避免使用这些保留字 goto 、const # 标识符 # 标识符 Java 对各种 变量、 方法和 类等要素命名时使用的字符序列称为标识符  技巧：凡是自己可以起名字的地方都叫标识符 # 定义合法标识符规则： 由 26 个英文字母大小写，0-9 ，_或 或 $ 组成  数字不可以开头。  不可以使用关键字和保留字，但能包含关键字和保留字。 Java 中严格区分大小写，长度无限制。  标识符不能包含空格 # Java 中的名称命名规范  包名：多单词组成时所有字母都小写：xxxyyyzzz  类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz  变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个 单词首字母大写：xxxYyyZzz  常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ # 变量 # 变量 内存中的一个存储区域 该区域的数据可以在同一类型范围内不断变化 变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值 # 注意 Java 中每个变量必须先声明，后使用 使用变量名来访问这块区域的数据 变量的作用域：其定义所在的一对 { } 内 变量只有在其作用域内才有效 同一个作用域内，不能定义重名的变量 # 声明 赋值 声明变量  语法：&lt;数据类型&gt; &lt; 变量名称 &gt;  例如：int var; 变量的赋值  语法：&lt;变量名称&gt; = &lt; 值 &gt;  例如：var = 10; 声明和赋值变量  语法： &lt;数据类型&gt; &lt; 变量名 &gt; = &lt; 初始化值 &gt;  例如：int var = 10; # 变量的分类 # 按数据类型 # 按声明的位置的不同  在方法体外，类体内声明的变量称为 成员变量 。  在方法体内部声明的变量称为 局部变量 。 ● 注意：二者在初始化值方面的异同: 同：都有生命周期 异：局部变量除形参外，需显式初始化 # 整数类型 java 的整型常量默认为 int 型，声明 long 型常量须后加‘l’或‘L’ # 浮点类型 浮点型常量有两种表示形式： 十进制数形式：如：5.12 512.0f .512 (必须有小数点） 科学计数法形式：如：5.12e2 512E2 100E-2  float: 单精度，尾数可以精确到 7 位有效数字。很多情况下，精度很难满足需求。 double: 双精度，精度是 float 的两倍。通常采用此类型。  Java 的浮点型常量默认为 double 型 型，明 声明 float 型常量，须后加‘f’ 或‘F’ 。 float 表示数值的范围比 long 还大 # 字符类型 char 型数据用来表示通常意义上 “字符”(2 字节) Java 中的所有字符都使用 Unicode 编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。 char 类型是可以进行运算的。因为它都对应有 Unicode 码。 # 字符型变量的三种表现形式 字符常量是用单引号 (‘ ’) 括起来的单个字符。例如：char c1 = ‘a’; char c2= ‘中’; char c3 = ‘9’;  Java 中还允许使用转义字符‘\\’来将其后的字符转变为特殊字符型常量。例如：char c3 = ‘\\n’; // '\\n’表示换行符 直接使用 Unicode 值来表示字符型常量：‘\\uXXXX’。其中，XXXX 代表一个十六进制整数。如：\\u000a 表示 \\n。 # 布尔类型 Java 虚拟机中没有任何供 boolean 值专用的字节码指令，Java 语言表达所操作的 boolean 值，在编译之后都使用 java 虚拟机中的 int 数据类型来代替：true 用 1 表示，false 用 0 表示。 # 基本数据类型转换 # 自动类型转换 容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为： byte,short,char 之间不会相互转换，他们三者在计算时首先转换为 int 类型。 boolean 类型不能与其它数据类型运算。 当把任何基本数据类型的值和字符串 (String) 进行连接运算时 (+)，基本数据类型的值将自动转化为字符串 (String) 类型。 # 强制类型转换 通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。 boolean 类型不可以转换为其它的数据类型。 # 字符串类型  使用方式与基本数据类型一致。例如：String str = “abcd”;  一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据。 # 进制 二进制 (binary) ：0,1 ，满 2 进 1. 以 0b 或 0B 开头。 八进制 (octal) ：0-7 ，满 8 进 1. 以数字 0 开头表示。 十六进制 (hex) ：0-9 及 A-F，满 16 进 1. 以 0x 或 0X 开头表示 # 运算符 运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。 算术运算符 赋值运算符 比较运算符（关系运算符） 逻辑运算符 位运算符 三元运算符 # 算术运算符 % 取余运算，结果的符号与被模数的符号相同 自增 1 不会改变本身变量的数据类型 # 赋值运算符 符号：= 支持连续赋值。 += 不会改变变量本身的数据类型 # 比较运算符 比较运算符的结果都是 boolean 型，也就是要么是 true，要么是 false。 instanceof 检查是否是类的对象 “Hello” instanceof String true # 逻辑运算符 &amp;— 逻辑与 | — 逻辑或 ！— 逻辑非 &amp;&amp; — 短路与 || — 短路或 ^ — 逻辑异或 逻辑运算符用于连接布尔型表达式 “&amp;” 和 “&amp;&amp;” 的区别： 单 &amp; 时，左边无论真假，右边都进行运算； 双 &amp; 时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。 # 位运算符 运算符 运算 范例 &lt;&lt;左移 3 &lt;&lt; 2 = 12 --&gt; 322=12 右移 3 &gt;&gt; 1 = 1 --&gt; 3/2=1 无符号右移 3 &gt;&gt;&gt; 1 = 1 --&gt; 3/2=1 &amp; 与运算 6 &amp; 3 = 2 | 或运算 6 | 3 = 7 ^ 异或运算 6 ^ 3 = 5 ~ 取反运算～6 = -7 &lt;&lt; 空位补 0，被移除的高位丢弃，空缺位补 0。 //&lt;&lt; 被移位的二进制最高位是 0，右移后，空缺位补 0；最高位是 1，空缺位补 1。 // &lt;&lt;&lt; 被移位二进制最高位无论是 0 或者是 1，空缺位都用 0 补 # 三元运算符 (条件表达式)? 表达式 1 ：表达式 2 # 运算符的优先级 只有单目运算符、三元运算符、 赋值运算符是从右向左运算的。 # 程序流程控制 顺序结构 分支结构 循环结构 # Scanner 1 &gt; 导包 import java.util.Scanner; 2&gt;Scanner 的实例化 Scanner scan = new Scanner(System.in); 3 &gt; 调用 Scanner 类的相关方法，来获取指定类型的变量 int num = scan.nextInt(); 对于 char 型的获取，Scanner 没有提供相应的方法 # switch-case switch(表达式){ case 常量1: 语句1; // break; case 常量2: 语句2; // break; … … case 常量N: 语句N; // break; default: 语句; // break; } 1&gt;break 语句用来在执行完一个 case 分支后使程序跳出 switch 语句块；如果没有 break，程序会顺序执行到 switch 结尾 2&gt;switch (表达式) 中表达式的值 必须是下述几种类型之一：byte ，short,char ，int， 枚举 (jdk 5.0) ，String (jdk 7.0)； 3&gt; default 子句是 可任选的 的。同时，位置也是灵活的。当没有匹配的 case 时，执行 default # 循环结构 for 循环 while 循环 do-while 循环 循环语句的四个组成部分 ①初始化部分 (init_statement) ②循环条件部分 (test_exp) ③循环体部分 (body_statement) ④迭代部分 (alter_statement) # for 循环 for (① 初始化 部分; ② 循环条件部分; ④ 迭代部分)｛ ③ 循环体部分; ｝ ①初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔 ④可以有多个变量更新，用逗号分隔 class ForTest{ public static void main(String[] args){ int sum; for(int i=1;i&lt;=100;i++){ if(1%2!=0){ System.out.println(i); sum=i; }else{ sum=1; } } System.out.println(sum); } } 错误：可能尚未初始化变量sum # while 循环 ①初始化部分 while (②循环条件部分)｛ ｛ ③循环体部分； ④迭代部分； } # do-while ①初始化部分； do{ ③ 循环体部分 ④ 迭代部分 } while (②循环条件部分); do-while 循环至少执行一次循环体 # 最简单 “无限” ” 循环 最简单 “无限” ” 循环： 格式：while (true) , for (;😉, 无限循环存在的原因是并不知道循环多少次， 需要 根据循环体内部某些 条件，来 控制 循环的结束 # currentTimeMillis() long start=System.currentTimeMillis(); # break continue break 语句用于终止某个语句块的执行，结束当前循环 continue 语句用于跳过其所在循环语句块的一次执行，继续下一次循环，结束当次循环 两个关键字后面都不能声明执行语句，会报错 # label class LabelTest{ public static void main(String[] args){ label:for(int i=1;i&lt;=4;i++){ for(int j=1;j&lt;=10;j++){ if(j%4==0){ continue label; } System.out.print(j); } System.out.println(); } } } # return return：并非专门用于结束循环的，它的功能是结束一个方法。当一个方法执行到一个 return 语句时，这个方法将被结束。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"1_Java语言概述","slug":"1-Java语言概述","date":"2021-01-08T11:52:47.000Z","updated":"2021-01-08T16:15:12.744Z","comments":true,"path":"2021/01/08/1-java-yu-yan-gai-shu/","link":"","permalink":"http://fsh010816.github.io/2021/01/08/1-java-yu-yan-gai-shu/","excerpt":"","text":"# Java 语言概述 # JDK JRE ・JDK = JRE + 开发工具集（例如 Javac 编译工具等） ・JRE = JVM + Java SE 标准类库 # JDK JDK (Java Development Kit Java 开发工具包) JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE 了。其中的开发工具：编译工具 (javac.exe) 打包工具 (jar.exe) 等 # JRE JRE (Java Runtime Environment Java 运行环境) 包括 Java 虚拟机 (JVM Java Virtual Machine) 和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可 # JDK 安装 安装时会跳出安装 jre。 # 环境变量 path：windows 系统执行命令时要搜寻的路径。 JAVA_HOME:bin 的上一层目录 path:%JAVA_HOME%/bin # 第一个 Java 程序 字节码文件名是类名 # 注释 1.// 单行 2./* 多行 */ /** 文档注释 */ 注释内容可以被 JDK 提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。 javadoc -encoding UTF-8 -charset UTF-8 -d myHello -author -version HelloJava.java # API API （Application Programming Interface, 应用程序编程接口）是 Java 提供的基本编程接口。 # 总结 1. 在一个 Java 源文件中可以声明多个 class, 只能有一个声明为 public 的，而且声明为 public 的类的类命必须与源文件名相同。 2. 程序的入口是 main 方法 3. 编译后，会生成一个或多个字节码文件，字节码文件的文件名与 Java 源文件中的类名相同 # IDE Integrated Development Environment","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-12-18T12:06:13.968Z","updated":"2020-12-18T12:06:13.968Z","comments":true,"path":"2020/12/18/hello-world/","link":"","permalink":"http://fsh010816.github.io/2020/12/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. # Quick Start # Create a new post $ hexo new \"My New Post\" More info: Writing # Run server $ hexo server More info: Server # Generate static files $ hexo generate More info: Generating # Deploy to remote sites $ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]}