{"meta":{"title":"Fsh","subtitle":"Fsh","description":"","author":"fsh","url":"http://Fsh010816.github.io","root":"/"},"pages":[{"title":"404","date":"2020-12-19T07:26:40.000Z","updated":"2020-12-19T07:27:00.079Z","comments":true,"path":"404/index.html","permalink":"http://fsh010816.github.io/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-12-19T07:15:58.000Z","updated":"2020-12-19T07:20:10.752Z","comments":true,"path":"categories/index.html","permalink":"http://fsh010816.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-12-19T07:18:58.000Z","updated":"2020-12-19T07:19:41.315Z","comments":true,"path":"about/index.html","permalink":"http://fsh010816.github.io/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-12-19T07:20:51.000Z","updated":"2020-12-19T07:21:08.106Z","comments":true,"path":"contact/index.html","permalink":"http://fsh010816.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-19T07:18:26.000Z","updated":"2020-12-19T07:20:23.582Z","comments":true,"path":"tags/index.html","permalink":"http://fsh010816.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-12-19T07:23:23.000Z","updated":"2020-12-19T07:23:41.727Z","comments":true,"path":"friends/index.html","permalink":"http://fsh010816.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"3-数组","slug":"3-数组","date":"2021-01-13T13:47:11.000Z","updated":"2021-01-18T06:50:37.675Z","comments":true,"path":"2021/01/13/3-shu-zu/","link":"","permalink":"http://fsh010816.github.io/2021/01/13/3-shu-zu/","excerpt":"","text":"# 数组 # 数组的概述 1 &gt; 数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型。 2 &gt; 创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址。 3 &gt; 数组的长度一旦确定，就不能修改。 # 一维数组 # 声明 type var[] 或 type[] var; Java 语言中声明数组时不能指定其长度 (数组中元素的数) # 初始化 # 静态初始化 静态初始化 ：在定义数组的同时就为数组元素分配空间并赋值。 int arr[] = new int[]{ 3, 9, 8}; 或 int[] arr = {3,9,8}; # 动态初始化 动态初始化 ：数组声明且为数组元素分配空间与赋值的操作分开进行 int[] arr = new int[3]; arr[0] = 3; arr[1] = 9; arr[2] = 8; # 数组元素的引用 数组元素下标可以是整型常量或整型表达式 数组元素下标从 0 开始 # 数组元素的默认初始化值 数组是引用类型，它的元素相当于类的成员变量，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化 # 内存解析 # 多维数组 # 二维数组的声明和初始化 静态初始化 int[][] arr = new int[][]{{3,8,2},{2,7},{9,0,1,6}}; System.out.println(arr.length); //3 System.out.println(arr[1].length); //2 int[][] arr = {{3,8,2},{2,7},{9,0,1,6}};//类型推断，只能一行时使用 注意特殊写法情况：int [] x,y []; x 是一维数组，y 是二维数组。 动态初始化 1 int[][] arr = new int[3][2]; System.out.println(arr[0]); //一维数组地址 System.out.println(arr[0][0]); //0 动态初始化 2 int[][] arr = new int[3][]; System.out.println(arr[0]); //null int[][] arr = new int[][3];//非法 # 二分法查找 前提：所要查找的数组有序 int arr1[] = new int[]{-98,-77,-55,-22,0,1,23,34,54,66,77,88,99}; int dest = 2; int head = 0; //初始的索引 int end = arr1.length - 1; //初始的末索引 boolean isFlag = true; while(head &lt;= end){ int middle = (head+end)/2; if(dest == arr1[middle]){ System.out.println(\"找到了，位置:\"+middle); isFlag = false; break; }else if(arr1[middle] &gt; dest){ end = middle - 1; }else{ head = middle + 1; } } if(isFlag){ System.out.println(\"没找到\"); } # 排序算法 # 衡量排序算法的优劣 1. 时间复杂度 2. 空间复杂度 3. 稳定性：若两个记录 A 和 B 的关键字值相等，但排序后 A、B 的先后次序保持不变，则称这种排序算法是稳定的。 # 分类 排序算法分类： 内部排序 和 外部排序 。 内部排序：整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。 外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。 # 冒泡排序 排序思想： 比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。 int arr[] = new int[]{22,33,11,-99,0,62,21}; //冒泡排序 for(int i = 0;i &lt; arr.length-1;i++){ for(int j = 0;j&lt;arr.length-1-i;j++){ if(arr[j]&gt;arr[j+1]){ int temp = arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } for(int i = 0;i&lt;arr.length;i++){ System.out.print(arr[i]+\" \"); } # 快速排序 # Arrays 工具类的使用 java.util.Arrays 1 boolean equals (int [] a,int [] b) 判断两个数组是否相等。 2 String toString (int [] a) 输出数组信息。 3 void fill (int [] a,int val) 将指定值填充到数组之中。 4 void sort (int [] a) 对数组进行排序。 5 int binarySearch (int [] a,int key) 对排序后的数组进行二分法检索指定的值。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"Eclipse","slug":"Eclipse","date":"2021-01-12T14:04:56.000Z","updated":"2021-01-12T15:56:29.914Z","comments":true,"path":"2021/01/12/eclipse/","link":"","permalink":"http://fsh010816.github.io/2021/01/12/eclipse/","excerpt":"","text":"# Eclipse # 结构 左侧： 结构 1： Package Explorer ​ 结构 2 ：Navigator ​ 结构 3：Outline 下面：结构 :4: Console # 配置 # 字符 # 字体 # 修改 new 菜单 # helloworld 先 new Java Project 在 src 下 new package 在包下 new class # 导入工程","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"2_Java基本语法","slug":"2-Java基本语法","date":"2021-01-09T02:11:52.000Z","updated":"2021-01-12T13:59:26.998Z","comments":true,"path":"2021/01/09/2-java-ji-ben-yu-fa/","link":"","permalink":"http://fsh010816.github.io/2021/01/09/2-java-ji-ben-yu-fa/","excerpt":"","text":"# Java 基本语法 # 关键字与保留字 # 关键字 定义：被 被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词） 特点： 关键字中所有字母都为小写 # 保留字 Java 保留字：现有 Java 版本尚未使用，但以后版本可能会作为关键字使 用。自己命名标识符时要避免使用这些保留字 goto 、const # 标识符 # 标识符 Java 对各种 变量、 方法和 类等要素命名时使用的字符序列称为标识符  技巧：凡是自己可以起名字的地方都叫标识符 # 定义合法标识符规则： 由 26 个英文字母大小写，0-9 ，_或 或 $ 组成  数字不可以开头。  不可以使用关键字和保留字，但能包含关键字和保留字。 Java 中严格区分大小写，长度无限制。  标识符不能包含空格 # Java 中的名称命名规范  包名：多单词组成时所有字母都小写：xxxyyyzzz  类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz  变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个 单词首字母大写：xxxYyyZzz  常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ # 变量 # 变量 内存中的一个存储区域 该区域的数据可以在同一类型范围内不断变化 变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值 # 注意 Java 中每个变量必须先声明，后使用 使用变量名来访问这块区域的数据 变量的作用域：其定义所在的一对 { } 内 变量只有在其作用域内才有效 同一个作用域内，不能定义重名的变量 # 声明 赋值 声明变量  语法：&lt;数据类型&gt; &lt; 变量名称 &gt;  例如：int var; 变量的赋值  语法：&lt;变量名称&gt; = &lt; 值 &gt;  例如：var = 10; 声明和赋值变量  语法： &lt;数据类型&gt; &lt; 变量名 &gt; = &lt; 初始化值 &gt;  例如：int var = 10; # 变量的分类 # 按数据类型 # 按声明的位置的不同  在方法体外，类体内声明的变量称为 成员变量 。  在方法体内部声明的变量称为 局部变量 。 ● 注意：二者在初始化值方面的异同: 同：都有生命周期 异：局部变量除形参外，需显式初始化 # 整数类型 java 的整型常量默认为 int 型，声明 long 型常量须后加‘l’或‘L’ # 浮点类型 浮点型常量有两种表示形式： 十进制数形式：如：5.12 512.0f .512 (必须有小数点） 科学计数法形式：如：5.12e2 512E2 100E-2  float: 单精度，尾数可以精确到 7 位有效数字。很多情况下，精度很难满足需求。 double: 双精度，精度是 float 的两倍。通常采用此类型。  Java 的浮点型常量默认为 double 型 型，明 声明 float 型常量，须后加‘f’ 或‘F’ 。 float 表示数值的范围比 long 还大 # 字符类型 char 型数据用来表示通常意义上 “字符”(2 字节) Java 中的所有字符都使用 Unicode 编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。 char 类型是可以进行运算的。因为它都对应有 Unicode 码。 # 字符型变量的三种表现形式 字符常量是用单引号 (‘ ’) 括起来的单个字符。例如：char c1 = ‘a’; char c2= ‘中’; char c3 = ‘9’;  Java 中还允许使用转义字符‘\\’来将其后的字符转变为特殊字符型常量。例如：char c3 = ‘\\n’; // '\\n’表示换行符 直接使用 Unicode 值来表示字符型常量：‘\\uXXXX’。其中，XXXX 代表一个十六进制整数。如：\\u000a 表示 \\n。 # 布尔类型 Java 虚拟机中没有任何供 boolean 值专用的字节码指令，Java 语言表达所操作的 boolean 值，在编译之后都使用 java 虚拟机中的 int 数据类型来代替：true 用 1 表示，false 用 0 表示。 # 基本数据类型转换 # 自动类型转换 容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为： byte,short,char 之间不会相互转换，他们三者在计算时首先转换为 int 类型。 boolean 类型不能与其它数据类型运算。 当把任何基本数据类型的值和字符串 (String) 进行连接运算时 (+)，基本数据类型的值将自动转化为字符串 (String) 类型。 # 强制类型转换 通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。 boolean 类型不可以转换为其它的数据类型。 # 字符串类型  使用方式与基本数据类型一致。例如：String str = “abcd”;  一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据。 # 进制 二进制 (binary) ：0,1 ，满 2 进 1. 以 0b 或 0B 开头。 八进制 (octal) ：0-7 ，满 8 进 1. 以数字 0 开头表示。 十六进制 (hex) ：0-9 及 A-F，满 16 进 1. 以 0x 或 0X 开头表示 # 运算符 运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。 算术运算符 赋值运算符 比较运算符（关系运算符） 逻辑运算符 位运算符 三元运算符 # 算术运算符 % 取余运算，结果的符号与被模数的符号相同 自增 1 不会改变本身变量的数据类型 # 赋值运算符 符号：= 支持连续赋值。 += 不会改变变量本身的数据类型 # 比较运算符 比较运算符的结果都是 boolean 型，也就是要么是 true，要么是 false。 instanceof 检查是否是类的对象 “Hello” instanceof String true # 逻辑运算符 &amp;— 逻辑与 | — 逻辑或 ！— 逻辑非 &amp;&amp; — 短路与 || — 短路或 ^ — 逻辑异或 逻辑运算符用于连接布尔型表达式 “&amp;” 和 “&amp;&amp;” 的区别： 单 &amp; 时，左边无论真假，右边都进行运算； 双 &amp; 时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。 # 位运算符 运算符 运算 范例 &lt;&lt;左移 3 &lt;&lt; 2 = 12 --&gt; 322=12 右移 3 &gt;&gt; 1 = 1 --&gt; 3/2=1 无符号右移 3 &gt;&gt;&gt; 1 = 1 --&gt; 3/2=1 &amp; 与运算 6 &amp; 3 = 2 | 或运算 6 | 3 = 7 ^ 异或运算 6 ^ 3 = 5 ~ 取反运算～6 = -7 &lt;&lt; 空位补 0，被移除的高位丢弃，空缺位补 0。 //&lt;&lt; 被移位的二进制最高位是 0，右移后，空缺位补 0；最高位是 1，空缺位补 1。 // &lt;&lt;&lt; 被移位二进制最高位无论是 0 或者是 1，空缺位都用 0 补 # 三元运算符 (条件表达式)? 表达式 1 ：表达式 2 # 运算符的优先级 只有单目运算符、三元运算符、 赋值运算符是从右向左运算的。 # 程序流程控制 顺序结构 分支结构 循环结构 # Scanner 1 &gt; 导包 import java.util.Scanner; 2&gt;Scanner 的实例化 Scanner scan = new Scanner(System.in); 3 &gt; 调用 Scanner 类的相关方法，来获取指定类型的变量 int num = scan.nextInt(); 对于 char 型的获取，Scanner 没有提供相应的方法 # switch-case switch(表达式){ case 常量1: 语句1; // break; case 常量2: 语句2; // break; … … case 常量N: 语句N; // break; default: 语句; // break; } 1&gt;break 语句用来在执行完一个 case 分支后使程序跳出 switch 语句块；如果没有 break，程序会顺序执行到 switch 结尾 2&gt;switch (表达式) 中表达式的值 必须是下述几种类型之一：byte ，short,char ，int， 枚举 (jdk 5.0) ，String (jdk 7.0)； 3&gt; default 子句是 可任选的 的。同时，位置也是灵活的。当没有匹配的 case 时，执行 default # 循环结构 for 循环 while 循环 do-while 循环 循环语句的四个组成部分 ①初始化部分 (init_statement) ②循环条件部分 (test_exp) ③循环体部分 (body_statement) ④迭代部分 (alter_statement) # for 循环 for (① 初始化 部分; ② 循环条件部分; ④ 迭代部分)｛ ③ 循环体部分; ｝ ①初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔 ④可以有多个变量更新，用逗号分隔 class ForTest{ public static void main(String[] args){ int sum; for(int i=1;i&lt;=100;i++){ if(1%2!=0){ System.out.println(i); sum=i; }else{ sum=1; } } System.out.println(sum); } } 错误：可能尚未初始化变量sum # while 循环 ①初始化部分 while (②循环条件部分)｛ ｛ ③循环体部分； ④迭代部分； } # do-while ①初始化部分； do{ ③ 循环体部分 ④ 迭代部分 } while (②循环条件部分); do-while 循环至少执行一次循环体 # 最简单 “无限” ” 循环 最简单 “无限” ” 循环： 格式：while (true) , for (;😉, 无限循环存在的原因是并不知道循环多少次， 需要 根据循环体内部某些 条件，来 控制 循环的结束 # currentTimeMillis() long start=System.currentTimeMillis(); # break continue break 语句用于终止某个语句块的执行，结束当前循环 continue 语句用于跳过其所在循环语句块的一次执行，继续下一次循环，结束当次循环 两个关键字后面都不能声明执行语句，会报错 # label class LabelTest{ public static void main(String[] args){ label:for(int i=1;i&lt;=4;i++){ for(int j=1;j&lt;=10;j++){ if(j%4==0){ continue label; } System.out.print(j); } System.out.println(); } } } # return return：并非专门用于结束循环的，它的功能是结束一个方法。当一个方法执行到一个 return 语句时，这个方法将被结束。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"1_Java语言概述","slug":"1-Java语言概述","date":"2021-01-08T11:52:47.000Z","updated":"2021-01-08T16:15:12.744Z","comments":true,"path":"2021/01/08/1-java-yu-yan-gai-shu/","link":"","permalink":"http://fsh010816.github.io/2021/01/08/1-java-yu-yan-gai-shu/","excerpt":"","text":"# Java 语言概述 # JDK JRE ・JDK = JRE + 开发工具集（例如 Javac 编译工具等） ・JRE = JVM + Java SE 标准类库 # JDK JDK (Java Development Kit Java 开发工具包) JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE 了。其中的开发工具：编译工具 (javac.exe) 打包工具 (jar.exe) 等 # JRE JRE (Java Runtime Environment Java 运行环境) 包括 Java 虚拟机 (JVM Java Virtual Machine) 和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可 # JDK 安装 安装时会跳出安装 jre。 # 环境变量 path：windows 系统执行命令时要搜寻的路径。 JAVA_HOME:bin 的上一层目录 path:%JAVA_HOME%/bin # 第一个 Java 程序 字节码文件名是类名 # 注释 1.// 单行 2./* 多行 */ /** 文档注释 */ 注释内容可以被 JDK 提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。 javadoc -encoding UTF-8 -charset UTF-8 -d myHello -author -version HelloJava.java # API API （Application Programming Interface, 应用程序编程接口）是 Java 提供的基本编程接口。 # 总结 1. 在一个 Java 源文件中可以声明多个 class, 只能有一个声明为 public 的，而且声明为 public 的类的类命必须与源文件名相同。 2. 程序的入口是 main 方法 3. 编译后，会生成一个或多个字节码文件，字节码文件的文件名与 Java 源文件中的类名相同 # IDE Integrated Development Environment","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-12-18T12:06:13.968Z","updated":"2020-12-18T12:06:13.968Z","comments":true,"path":"2020/12/18/hello-world/","link":"","permalink":"http://fsh010816.github.io/2020/12/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. # Quick Start # Create a new post $ hexo new \"My New Post\" More info: Writing # Run server $ hexo server More info: Server # Generate static files $ hexo generate More info: Generating # Deploy to remote sites $ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]}