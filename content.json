{"meta":{"title":"Fsh","subtitle":"Fsh","description":"","author":"fsh","url":"http://Fsh010816.github.io","root":"/"},"pages":[{"title":"404","date":"2020-12-19T07:26:40.000Z","updated":"2020-12-19T07:27:00.079Z","comments":true,"path":"404/index.html","permalink":"http://fsh010816.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2020-12-19T07:18:58.000Z","updated":"2020-12-19T07:19:41.315Z","comments":true,"path":"about/index.html","permalink":"http://fsh010816.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-12-19T07:23:23.000Z","updated":"2020-12-19T07:23:41.727Z","comments":true,"path":"friends/index.html","permalink":"http://fsh010816.github.io/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-12-19T07:15:58.000Z","updated":"2020-12-19T07:20:10.752Z","comments":true,"path":"categories/index.html","permalink":"http://fsh010816.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-12-19T07:20:51.000Z","updated":"2020-12-19T07:21:08.106Z","comments":true,"path":"contact/index.html","permalink":"http://fsh010816.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-19T07:18:26.000Z","updated":"2020-12-19T07:20:23.582Z","comments":true,"path":"tags/index.html","permalink":"http://fsh010816.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"4-面向对象(上)","slug":"4-面向对象-上","date":"2021-01-18T07:02:37.000Z","updated":"2021-01-19T12:31:21.032Z","comments":true,"path":"2021/01/18/4-mian-xiang-dui-xiang-shang/","link":"","permalink":"http://fsh010816.github.io/2021/01/18/4-mian-xiang-dui-xiang-shang/","excerpt":"","text":"# 面向对象 (上) # 类 (Class) 和对象 (Object) 类是对一类事物的描述，是抽象的、概念上的定义 对象是实际存在的该类事物的每个个体，因而也称为实例 (instance)。 # 类的成员 1 &gt; 属 性：对应类中的成员变量 2 &gt; 行 为：对应类中的成员方法 Field = 属性 = 成员变量 = 域、字段，Method = (成员) 方法 = 函数 创建类的对象 = 类的实例化 = 实例化类 # 类和对象的使用 1. 创建类，设计类的成员 2. 创建类的对象 类名 对象名 = new 类名(); 3. 通过 “对象。属性” 或 “对象。方法” 调用对象的结构 # 类 修饰符 class 类名 { 属性声明; 方法声明; } 类的正文要用 { } 括起来 # 内存解析 编译完程序以后，生成一个或多个字节码文件， 我们使用 JVM 中的类的加载器和解释器对生成的字节码文件进行解释运行，意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析。 堆： 存放对象实例 对象的属性（非 static）new 出来的结构 对象（非 static 成员变量）数组 栈： 存储局部变量 方法区（Method Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 常量池 静态域 # 对象的内存解析 # 匿名对象 我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。 如：new Person ().shout (); 使用情况 1. 如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。 2. 我们经常将匿名对象作为实参传递给一个方法调用。 # 属性 (成员变量) 局部变量 # 相同点 1. 定义变量的格式：数据类型 变量名 = 变量值 2. 先声明，后使用 3. 变量都有其对应的作用域 # 不同点 1. 在类中声明的位置不同 成员变量：在方法体外，类体内声明的变量 局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量 2. 关于权限修饰符的不同 属性：可以在声明属性时，指明其权限，使用权限修饰符 ​ private、public、缺省、protected 局部变量：不可使用权限修饰符 3. 默认初始化值 属性：根据其类型，都有默认初始化值 局部变量：没有默认初始化值 ​ 调用局部变量前，必须显示赋值 ​ 特别地，形参在调用时，赋值即可 4. 在内存中加载的位置 属性：堆（非 static） 局部变量：栈 # 方法 Java 里的方法不能独立存在，所有的方法必须定义在类里。 # 声明 权限修饰符 返回值类型 方法名 （参数类型 形参1,参数类型 形参2, …）｛ 方法体程序代码 return 返回值; ｝ 返回值类型： ​ 没有返回值：void。 如果使用 return, 只能 \"return;\"，表示结束此方法的意思 ​ 有返回值，声明出返回值的类型。 # tips 方法的使用中，可以调用当前类的属性或方法 ​ （例外：static 方法访问非 static，编译不通过 。） 方法中，不可以定义方法 # 重载 概念：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。 # 可变个数的形参 JavaSE 5.0 中提供了 Varargs (variable number of arguments) 机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。 声明格式：方法名 (参数的类型名 … 参数名) 此参数名也有 length 属性 可变参数：方法参数部分指定类型的参数个数是可变多个：0 个，1 个或多个 可变参数方法的使用与方法参数部分使用数组是一致的 # 方法参数的值传递机制 Java 里方法的参数传递方式只有一种：值传递。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。 形参是基本数据类型：将实参基本数据类型变量的 “数据值” 传递给形参 形参是引用数据类型：将实参引用数据类型变量的 “地址值” 传递给形参 # 封装和隐藏 信息的封装和隐藏 Java 中通过将数据声明为私有的 (private)，再提供公共的（public）方法:getXxx () 和 setXxx () 实现对该属性的操作，以实现下述目的： 隐藏一个类中不需要对外提供的实现细节； 使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作； 便于修改，增强代码的可维护性 # 权限修饰符 4 种权限修饰符都可以修饰类的内部结构：属性、方法、构造器、内部类 修饰类，只能用：缺省和 public # 构造器 # 构造器的特征 它具有与类相同的名称 它不声明返回值类型。（与声明为 void 不同） 不能被 static、final、synchronized、abstract、native 修饰，不能有 return 语句返回值 # 构造器的作用 创建对象；给对象进行初始化 如：Order o = new Order (); Person p = new Person (“Peter”,15); # 语法格式 ： 修饰符名 类名 ( 参数列表) { 初始化语句； } 根据参数不同，构造器可以分为如下两类：  隐式无参构造器（系统默认提供）  显式定义一个或多个（无参、有参） # 注意： Java 语言中，每个类都至少有一个 构造器  默认构造器的修饰符与所属类的修饰符一致  一旦 显式定义了 构造器， 则系统 不再 提供默认 构造 器  一个类可以创建多个 重载 的构造器  父类的构造器不可被子类继承 # 属性赋值过程 赋值的位置： ① 默认初始化 ② 显式初始化 ③ 构造器中初始化 ④ 通过 “对象。属性 “或 “对象。方法” 的方式赋值 赋值的先后顺序：① - ② - ③ - ④ # JavaBean JavaBean 是一种 Java 语言写成的可重用组件。 所谓 javaBean，是指符合如下标准的 Java 类： 类是公共的 有一个无参的公共的构造器 有属性，且有对应的 get、set 方法 # this this 关键字的使用： 1.this 可以用来修饰、调用：属性、方法、构造器 2.this 修饰属性和方法： this 理解为：当前对象 或 当前正在创建的对象 2.1 在类的方法中，我们可以使用 \"this. 属性\" 或 \"this. 方法\" 的方式，调用当前对象属性或方法。但是，通常情况下，我们都选择省略 \"this.\"。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用 \"this. 变量\" 的方式，表明此变量是属性，而非形参。 2.2 在类的构造器中，我们可以使用 \"this. 属性\" 或 \"this. 方法\" 的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都选择省略 \"this.\"。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用 \"this. 变量\" 的方式，表明此变量是属性，而非形参。 2.3 使用 this 访问属性和方法时，如果在本类中未找到，会从父类中查找 this 调用构造器 ① 我们在类的构造器中，可以显式的使用 \"this (形参列表)\" 方式，调用本类中指定的其他构造器 ② 构造器中不能通过 \"this (形参列表)\" 方式调用自己 ③ 如果一个类中有 n 个构造器，则最多有 n - 1 构造器中使用了 \"this (形参列表)\" ④ 规定：\"this (形参列表)\" 必须声明在当前构造器的首行 ⑤ 构造器内部，最多只能声明一个 \"this (形参列表)\"，用来调用其他的构造器 # import 在源文件中使用 import 显式的导入指定包下的类或接口 如果已经导入 java.a 包下的类。那么如果需要使用 a 包的子包下的类的话，仍然需要导入。使用 \"xxx.*\" 方式表明可以调用 xxx 包下的所有结构。但是如果使用的是 xxx 子包下的结构，则仍需要显式导入 import static 组合的使用：调用指定类或接口下的静态的属性或方法 import static java.lang.System.*; out.println(\"hello\");","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"3-数组","slug":"3-数组","date":"2021-01-13T13:47:11.000Z","updated":"2021-01-18T06:50:37.675Z","comments":true,"path":"2021/01/13/3-shu-zu/","link":"","permalink":"http://fsh010816.github.io/2021/01/13/3-shu-zu/","excerpt":"","text":"# 数组 # 数组的概述 1 &gt; 数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型。 2 &gt; 创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址。 3 &gt; 数组的长度一旦确定，就不能修改。 # 一维数组 # 声明 type var[] 或 type[] var; Java 语言中声明数组时不能指定其长度 (数组中元素的数) # 初始化 # 静态初始化 静态初始化 ：在定义数组的同时就为数组元素分配空间并赋值。 int arr[] = new int[]{ 3, 9, 8}; 或 int[] arr = {3,9,8}; # 动态初始化 动态初始化 ：数组声明且为数组元素分配空间与赋值的操作分开进行 int[] arr = new int[3]; arr[0] = 3; arr[1] = 9; arr[2] = 8; # 数组元素的引用 数组元素下标可以是整型常量或整型表达式 数组元素下标从 0 开始 # 数组元素的默认初始化值 数组是引用类型，它的元素相当于类的成员变量，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化 # 内存解析 # 多维数组 # 二维数组的声明和初始化 静态初始化 int[][] arr = new int[][]{{3,8,2},{2,7},{9,0,1,6}}; System.out.println(arr.length); //3 System.out.println(arr[1].length); //2 int[][] arr = {{3,8,2},{2,7},{9,0,1,6}};//类型推断，只能一行时使用 注意特殊写法情况：int [] x,y []; x 是一维数组，y 是二维数组。 动态初始化 1 int[][] arr = new int[3][2]; System.out.println(arr[0]); //一维数组地址 System.out.println(arr[0][0]); //0 动态初始化 2 int[][] arr = new int[3][]; System.out.println(arr[0]); //null int[][] arr = new int[][3];//非法 # 二分法查找 前提：所要查找的数组有序 int arr1[] = new int[]{-98,-77,-55,-22,0,1,23,34,54,66,77,88,99}; int dest = 2; int head = 0; //初始的索引 int end = arr1.length - 1; //初始的末索引 boolean isFlag = true; while(head &lt;= end){ int middle = (head+end)/2; if(dest == arr1[middle]){ System.out.println(\"找到了，位置:\"+middle); isFlag = false; break; }else if(arr1[middle] &gt; dest){ end = middle - 1; }else{ head = middle + 1; } } if(isFlag){ System.out.println(\"没找到\"); } # 排序算法 # 衡量排序算法的优劣 1. 时间复杂度 2. 空间复杂度 3. 稳定性：若两个记录 A 和 B 的关键字值相等，但排序后 A、B 的先后次序保持不变，则称这种排序算法是稳定的。 # 分类 排序算法分类： 内部排序 和 外部排序 。 内部排序：整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。 外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。 # 冒泡排序 排序思想： 比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。 int arr[] = new int[]{22,33,11,-99,0,62,21}; //冒泡排序 for(int i = 0;i &lt; arr.length-1;i++){ for(int j = 0;j&lt;arr.length-1-i;j++){ if(arr[j]&gt;arr[j+1]){ int temp = arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } for(int i = 0;i&lt;arr.length;i++){ System.out.print(arr[i]+\" \"); } # 快速排序 # Arrays 工具类的使用 java.util.Arrays 1 boolean equals (int [] a,int [] b) 判断两个数组是否相等。 2 String toString (int [] a) 输出数组信息。 3 void fill (int [] a,int val) 将指定值填充到数组之中。 4 void sort (int [] a) 对数组进行排序。 5 int binarySearch (int [] a,int key) 对排序后的数组进行二分法检索指定的值。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"Eclipse","slug":"Eclipse","date":"2021-01-12T14:04:56.000Z","updated":"2021-01-12T15:56:29.914Z","comments":true,"path":"2021/01/12/eclipse/","link":"","permalink":"http://fsh010816.github.io/2021/01/12/eclipse/","excerpt":"","text":"# Eclipse # 结构 左侧： 结构 1： Package Explorer ​ 结构 2 ：Navigator ​ 结构 3：Outline 下面：结构 :4: Console # 配置 # 字符 # 字体 # 修改 new 菜单 # helloworld 先 new Java Project 在 src 下 new package 在包下 new class # 导入工程","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"2_Java基本语法","slug":"2-Java基本语法","date":"2021-01-09T02:11:52.000Z","updated":"2021-01-12T13:59:26.998Z","comments":true,"path":"2021/01/09/2-java-ji-ben-yu-fa/","link":"","permalink":"http://fsh010816.github.io/2021/01/09/2-java-ji-ben-yu-fa/","excerpt":"","text":"# Java 基本语法 # 关键字与保留字 # 关键字 定义：被 被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词） 特点： 关键字中所有字母都为小写 # 保留字 Java 保留字：现有 Java 版本尚未使用，但以后版本可能会作为关键字使 用。自己命名标识符时要避免使用这些保留字 goto 、const # 标识符 # 标识符 Java 对各种 变量、 方法和 类等要素命名时使用的字符序列称为标识符  技巧：凡是自己可以起名字的地方都叫标识符 # 定义合法标识符规则： 由 26 个英文字母大小写，0-9 ，_或 或 $ 组成  数字不可以开头。  不可以使用关键字和保留字，但能包含关键字和保留字。 Java 中严格区分大小写，长度无限制。  标识符不能包含空格 # Java 中的名称命名规范  包名：多单词组成时所有字母都小写：xxxyyyzzz  类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz  变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个 单词首字母大写：xxxYyyZzz  常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ # 变量 # 变量 内存中的一个存储区域 该区域的数据可以在同一类型范围内不断变化 变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值 # 注意 Java 中每个变量必须先声明，后使用 使用变量名来访问这块区域的数据 变量的作用域：其定义所在的一对 { } 内 变量只有在其作用域内才有效 同一个作用域内，不能定义重名的变量 # 声明 赋值 声明变量  语法：&lt;数据类型&gt; &lt; 变量名称 &gt;  例如：int var; 变量的赋值  语法：&lt;变量名称&gt; = &lt; 值 &gt;  例如：var = 10; 声明和赋值变量  语法： &lt;数据类型&gt; &lt; 变量名 &gt; = &lt; 初始化值 &gt;  例如：int var = 10; # 变量的分类 # 按数据类型 # 按声明的位置的不同  在方法体外，类体内声明的变量称为 成员变量 。  在方法体内部声明的变量称为 局部变量 。 ● 注意：二者在初始化值方面的异同: 同：都有生命周期 异：局部变量除形参外，需显式初始化 # 整数类型 java 的整型常量默认为 int 型，声明 long 型常量须后加‘l’或‘L’ # 浮点类型 浮点型常量有两种表示形式： 十进制数形式：如：5.12 512.0f .512 (必须有小数点） 科学计数法形式：如：5.12e2 512E2 100E-2  float: 单精度，尾数可以精确到 7 位有效数字。很多情况下，精度很难满足需求。 double: 双精度，精度是 float 的两倍。通常采用此类型。  Java 的浮点型常量默认为 double 型 型，明 声明 float 型常量，须后加‘f’ 或‘F’ 。 float 表示数值的范围比 long 还大 # 字符类型 char 型数据用来表示通常意义上 “字符”(2 字节) Java 中的所有字符都使用 Unicode 编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。 char 类型是可以进行运算的。因为它都对应有 Unicode 码。 # 字符型变量的三种表现形式 字符常量是用单引号 (‘ ’) 括起来的单个字符。例如：char c1 = ‘a’; char c2= ‘中’; char c3 = ‘9’;  Java 中还允许使用转义字符‘\\’来将其后的字符转变为特殊字符型常量。例如：char c3 = ‘\\n’; // '\\n’表示换行符 直接使用 Unicode 值来表示字符型常量：‘\\uXXXX’。其中，XXXX 代表一个十六进制整数。如：\\u000a 表示 \\n。 # 布尔类型 Java 虚拟机中没有任何供 boolean 值专用的字节码指令，Java 语言表达所操作的 boolean 值，在编译之后都使用 java 虚拟机中的 int 数据类型来代替：true 用 1 表示，false 用 0 表示。 # 基本数据类型转换 # 自动类型转换 容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为： byte,short,char 之间不会相互转换，他们三者在计算时首先转换为 int 类型。 boolean 类型不能与其它数据类型运算。 当把任何基本数据类型的值和字符串 (String) 进行连接运算时 (+)，基本数据类型的值将自动转化为字符串 (String) 类型。 # 强制类型转换 通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。 boolean 类型不可以转换为其它的数据类型。 # 字符串类型  使用方式与基本数据类型一致。例如：String str = “abcd”;  一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据。 # 进制 二进制 (binary) ：0,1 ，满 2 进 1. 以 0b 或 0B 开头。 八进制 (octal) ：0-7 ，满 8 进 1. 以数字 0 开头表示。 十六进制 (hex) ：0-9 及 A-F，满 16 进 1. 以 0x 或 0X 开头表示 # 运算符 运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。 算术运算符 赋值运算符 比较运算符（关系运算符） 逻辑运算符 位运算符 三元运算符 # 算术运算符 % 取余运算，结果的符号与被模数的符号相同 自增 1 不会改变本身变量的数据类型 # 赋值运算符 符号：= 支持连续赋值。 += 不会改变变量本身的数据类型 # 比较运算符 比较运算符的结果都是 boolean 型，也就是要么是 true，要么是 false。 instanceof 检查是否是类的对象 “Hello” instanceof String true # 逻辑运算符 &amp;— 逻辑与 | — 逻辑或 ！— 逻辑非 &amp;&amp; — 短路与 || — 短路或 ^ — 逻辑异或 逻辑运算符用于连接布尔型表达式 “&amp;” 和 “&amp;&amp;” 的区别： 单 &amp; 时，左边无论真假，右边都进行运算； 双 &amp; 时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。 # 位运算符 运算符 运算 范例 &lt;&lt;左移 3 &lt;&lt; 2 = 12 --&gt; 322=12 右移 3 &gt;&gt; 1 = 1 --&gt; 3/2=1 无符号右移 3 &gt;&gt;&gt; 1 = 1 --&gt; 3/2=1 &amp; 与运算 6 &amp; 3 = 2 | 或运算 6 | 3 = 7 ^ 异或运算 6 ^ 3 = 5 ~ 取反运算～6 = -7 &lt;&lt; 空位补 0，被移除的高位丢弃，空缺位补 0。 //&lt;&lt; 被移位的二进制最高位是 0，右移后，空缺位补 0；最高位是 1，空缺位补 1。 // &lt;&lt;&lt; 被移位二进制最高位无论是 0 或者是 1，空缺位都用 0 补 # 三元运算符 (条件表达式)? 表达式 1 ：表达式 2 # 运算符的优先级 只有单目运算符、三元运算符、 赋值运算符是从右向左运算的。 # 程序流程控制 顺序结构 分支结构 循环结构 # Scanner 1 &gt; 导包 import java.util.Scanner; 2&gt;Scanner 的实例化 Scanner scan = new Scanner(System.in); 3 &gt; 调用 Scanner 类的相关方法，来获取指定类型的变量 int num = scan.nextInt(); 对于 char 型的获取，Scanner 没有提供相应的方法 # switch-case switch(表达式){ case 常量1: 语句1; // break; case 常量2: 语句2; // break; … … case 常量N: 语句N; // break; default: 语句; // break; } 1&gt;break 语句用来在执行完一个 case 分支后使程序跳出 switch 语句块；如果没有 break，程序会顺序执行到 switch 结尾 2&gt;switch (表达式) 中表达式的值 必须是下述几种类型之一：byte ，short,char ，int， 枚举 (jdk 5.0) ，String (jdk 7.0)； 3&gt; default 子句是 可任选的 的。同时，位置也是灵活的。当没有匹配的 case 时，执行 default # 循环结构 for 循环 while 循环 do-while 循环 循环语句的四个组成部分 ①初始化部分 (init_statement) ②循环条件部分 (test_exp) ③循环体部分 (body_statement) ④迭代部分 (alter_statement) # for 循环 for (① 初始化 部分; ② 循环条件部分; ④ 迭代部分)｛ ③ 循环体部分; ｝ ①初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔 ④可以有多个变量更新，用逗号分隔 class ForTest{ public static void main(String[] args){ int sum; for(int i=1;i&lt;=100;i++){ if(1%2!=0){ System.out.println(i); sum=i; }else{ sum=1; } } System.out.println(sum); } } 错误：可能尚未初始化变量sum # while 循环 ①初始化部分 while (②循环条件部分)｛ ｛ ③循环体部分； ④迭代部分； } # do-while ①初始化部分； do{ ③ 循环体部分 ④ 迭代部分 } while (②循环条件部分); do-while 循环至少执行一次循环体 # 最简单 “无限” ” 循环 最简单 “无限” ” 循环： 格式：while (true) , for (;😉, 无限循环存在的原因是并不知道循环多少次， 需要 根据循环体内部某些 条件，来 控制 循环的结束 # currentTimeMillis() long start=System.currentTimeMillis(); # break continue break 语句用于终止某个语句块的执行，结束当前循环 continue 语句用于跳过其所在循环语句块的一次执行，继续下一次循环，结束当次循环 两个关键字后面都不能声明执行语句，会报错 # label class LabelTest{ public static void main(String[] args){ label:for(int i=1;i&lt;=4;i++){ for(int j=1;j&lt;=10;j++){ if(j%4==0){ continue label; } System.out.print(j); } System.out.println(); } } } # return return：并非专门用于结束循环的，它的功能是结束一个方法。当一个方法执行到一个 return 语句时，这个方法将被结束。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"1_Java语言概述","slug":"1-Java语言概述","date":"2021-01-08T11:52:47.000Z","updated":"2021-01-08T16:15:12.744Z","comments":true,"path":"2021/01/08/1-java-yu-yan-gai-shu/","link":"","permalink":"http://fsh010816.github.io/2021/01/08/1-java-yu-yan-gai-shu/","excerpt":"","text":"# Java 语言概述 # JDK JRE ・JDK = JRE + 开发工具集（例如 Javac 编译工具等） ・JRE = JVM + Java SE 标准类库 # JDK JDK (Java Development Kit Java 开发工具包) JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE 了。其中的开发工具：编译工具 (javac.exe) 打包工具 (jar.exe) 等 # JRE JRE (Java Runtime Environment Java 运行环境) 包括 Java 虚拟机 (JVM Java Virtual Machine) 和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可 # JDK 安装 安装时会跳出安装 jre。 # 环境变量 path：windows 系统执行命令时要搜寻的路径。 JAVA_HOME:bin 的上一层目录 path:%JAVA_HOME%/bin # 第一个 Java 程序 字节码文件名是类名 # 注释 1.// 单行 2./* 多行 */ /** 文档注释 */ 注释内容可以被 JDK 提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。 javadoc -encoding UTF-8 -charset UTF-8 -d myHello -author -version HelloJava.java # API API （Application Programming Interface, 应用程序编程接口）是 Java 提供的基本编程接口。 # 总结 1. 在一个 Java 源文件中可以声明多个 class, 只能有一个声明为 public 的，而且声明为 public 的类的类命必须与源文件名相同。 2. 程序的入口是 main 方法 3. 编译后，会生成一个或多个字节码文件，字节码文件的文件名与 Java 源文件中的类名相同 # IDE Integrated Development Environment","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-12-18T12:06:13.968Z","updated":"2020-12-18T12:06:13.968Z","comments":true,"path":"2020/12/18/hello-world/","link":"","permalink":"http://fsh010816.github.io/2020/12/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. # Quick Start # Create a new post $ hexo new \"My New Post\" More info: Writing # Run server $ hexo server More info: Server # Generate static files $ hexo generate More info: Generating # Deploy to remote sites $ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]}